<!DOCTYPE html>
<html>
<head>
	<title>МЗКІТ. Лекція №9 </title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
	<div class="paper">
		<div id="colontitle">МЗКІТ. Лекція №9 </div>
		<ul class="lec-menu">
			<li><a href="index.html">Зміст</a></li>
			<li><a href="lec-01.html">01</a></li>
			<li><a href="lec-02.html">02</a></li>
			<li><a href="lec-03.html">03</a></li>
			<li><a href="lec-04.html">04</a></li>
			<li><a href="lec-05.html">05</a></li>
			<li><a href="lec-06.html">06</a></li>
			<li><a href="lec-07.html">07</a></li>
			<li><a href="lec-08.html">08</a></li>
			<li><a href="lec-09.html">09</a></li>
			<li><a href="lec-10.html">10</a></li>
			<li><a href="lec-11.html">11</a></li>
			<li><a href="lec-12.html">12</a></li>
			<li><a href="lec-13.html">13</a></li>
			<li><a href="lec-14.html">14</a></li>
			<li><a href="lec-15.html">15</a></li>
			<li><a href="lec-16.html">16</a></li>
		</ul>
		<h1>Типи даних та перетворення типів</h1>
		<div class="content-board">
			<ol>
				<li>
					<a href="#h01">Тип даних</a>
				</li>
				<li>
					<a href="#h02">Число</a>
				</li>
				<li>
					<a href="#bigint">BigInt</a>
				</li>
				<li>
					<a href="#h03">Рядок</a>
				</li>
				<li>
					<a href="#h04">Булевий (логічний) тип</a>
				</li>
				<li>
					<a href="#-null-">Значення "null"</a>
				</li>
				<li>
					<a href="#-undefined-">Значення "undefined"</a>
				</li>
				<li>
					<a href="#h05">Об'єкти та символи</a>
				</li>
				<li>
					<a href="#-typeof-type-typeof-">Оператор typeof [#type-typeof]</a>
				</li>
				<li>
					<a href="#h06">Підсумок</a>
				</li>
				<li>
					<a href="#h07">ПЕРЕТВОРЕННЯ ТИПІВ</a>
				</li>
				<li>
					<a href="#h08">Рядкове перетворення</a>
				</li>
				<li>
					<a href="#h09">Чисельне перетворення</a>
				</li>
				<li>
					<a href="#h010">Логічне перетворення</a>
				</li>
				<li>
					<a href="#h011">Разом</a>
				</li>
				<li>
					<a href="#h012">Контрольні запитання</a>
				</li>
			</ol>
		</div>
		<h1 id="#h01">Тип даних</h1>
		<p>
			Значення в JavaScript завжди відноситься до даних певного типу. Наприклад, це може бути рядок або число.
		</p>

		<p>
			Є вісім основних типів даних в JavaScript. У цьому розділі ми розглянемо їх загалом, а в наступних розділах поговоримо докладніше про кожного.
		</p>

		<p>
			Змінна в JavaScript може містити будь-які дані. В один момент там може бути рядок, а в іншій-число:
		</p>

		<pre>
// Не буде помилкою
let message = "hello";
message = 123456;
		</pre>
		<p>
			Мови програмування, в яких таке можливо, називаються динамічно типізованими. Це означає, що типи даних є, але змінні не прив'язані до жодного з них.
		</p>
		<h2 id="#h02">Число</h2>
		<pre>
let n = 123;
n = 12.345;
		</pre>
		<p>
			Числовий тип даних (<code>number</code>) представляє як цілочисельні значення, так і числа з плаваючою точкою.
		</p>

		<p>
			Існує безліч операцій для чисел, наприклад, множення<code>*</code>, ділення<code>/</code>, додавання<code>+</code>, віднімання <code>-</code> і так далі.
		</p>

		<p>
			Крім звичайних чисел, існують так звані спеціальні числові значення, які відносяться до цього типу даних: <code>Infinity</code>, <code>-Infinity</code> і <code>NaN</code>.
		</p>

		<p>
			<code>Infinity</code> являє собою математичну <a href="https://ru.wikipedia.org/wiki/Бесконечность#В_математике">нескінченність</a>∞. Це особливе значення, яке більше будь-якого числа.
		</p>

		<p>
			Ми можемо отримати його в результаті поділу на нуль:
		</p>

		<pre>
alert( 1 / 0 ); // Infinity
		</pre>
		<p>
			Або задати його явно:
		</p>

		<pre>
alert( Infinity ); // Infinity
		</pre>
		<ul>
			<li><code>NaN</code> означає обчислювальну помилку. Це результат неправильної або невизначеної математичної операції, наприклад:</li>
		</ul>
		<pre>
alert ("не число" / 2); // NaN, такий поділ є помилкою
		</pre>
		<p>
			Будь-яка операція з <code>NaN</code> повертає <code>NaN</code>:
		</p>

		<pre>
alert("не число"/2 + 5); // NaN
		</pre>
		<p>
			Якщо десь в математичному вираженні є <code>NaN</code>, то результатом обчислень з його участю буде <code>NaN</code>.
		</p>

		<p class="notice">
			Математичні операції в JavaScript безпечні. Ми можемо робити що завгодно: ділити на нуль, поводитися з нечисловими рядками як з числами і т. д. У гіршому випадку ми отримаємо <code>NaN</code> як результат виконання.
		</p>

		<p>
			Спеціальні числові значення відносяться до типучисло. Звичайно, це не числа в звичному значенні цього слова.
		</p>

		<h2 id="bigint">BigInt</h2>
		<p>
			У JavaScript тип number не може містити числа більше, ніж <code>(2<sup>53</sup>-1)</code> (тобто <code>9007199254740991</code>), або менше, ніж <code>-(2<sup>53</sup>-1)</code> для негативних чисел. Це технічне обмеження викликано їх внутрішнім поданням.
		</p>

		<p>
			Для більшості випадків цього достатньо. Але іноді нам потрібні дійсно гігантські числа, наприклад, в криптографії або при використанні мітки часу (timestamp) з мікросекундами.
		</p>

		<p>
			Тип<code>BigInt</code> був доданий в JavaScript, щоб дати можливість працювати з цілими числами довільної довжини.
		</p>

		<p>
			Щоб створити значення типу <code>BigInt</code>, необхідно додати <code>n</code> в кінець числового літерала:
		</p>

		<pre>
// символ "n" в кінці означає, Що це BigInt
const bigInt = 1234567890123456789012345678901234567890n;
		</pre>


		<h2 id="h03">Рядок</h2>
		<p>
			Рядок (<code>string</code>) в JavaScript повинна бути укладена в лапки.
		</p>

		<pre>
let str = " Привіт";
let str2 ='одинарні лапки теж підійдуть';
let phrase =`зворотні лапки дозволяють вбудовувати змінні ${str}`;
		</pre>
		<p>
			У JavaScript існує три типи лапок.
		</p>
		<ol>
			<li>Подвійні лапки: <code>Привіт</code>.</li>
			<li>Одинарні лапки: Привіт.</li>
			<li>Зворотні лапки: <code> &amp; #96; Привіт&#96;</code>.</li>
		</ol>
		<p>
			Подвійні або одинарні лапки є простими, між ними немає різниці в JavaScript.
		</p>

		<p>
			Зворотні ж лапки мають розширену функціональність. Вони дозволяють нам вбудовувати вирази в рядок, укладаючи їх в <code>${ ... }</code>. Наприклад:
		</p>

		<pre>
let name = "Іван";
// Вставимо змінну
alert `Привіт, ${name}!` ); // Привіт, Іван!
// Вставимо вираз
alert `результат:${1 + 2}` ); // результат: 3
		</pre>
		<p>
			Вираз всередині <code>$ { ... }</code> обчислюється, і його результат стає частиною рядка. Ми можемо покласти туди все, що завгодно: змінну <code>name</code>, або вираз <code>1 + 2</code>, або щось більш складне.
		</p>

		<p>
			Зверніть увагу, що це можна робити тільки в зворотних лапках. Інші лапки не мають такої функціональності вбудовування!
		</p>

		<pre>
alert ("результат: ${1 + 2}" ); // результат: $ {1 + 2} (подвійні лапки нічого не роблять)
		</pre>


		<p>
			Рядок може містити нуль символів (бути порожній), один символ або безліч. Не існує окремого типу даних для зберігання одного символу
		</p>
		<h2 id="h04">Булевий (логічний) тип</h2>
		<p>
			Булевий тип (<code>boolean</code>) може приймати тільки два значення: <code>true</code> (істина) і <code>false</code> (брехня).
		</p>

		<p>
			Такий тип, як правило, використовується для зберігання значень так / ні <code>true</code> означає Так, правильно, а <code>false</code> означаєНі, не правильно.
		</p>

		<p>
			Наприклад:
		</p>

		<pre>
let nameFieldChecked = true; // так, поле відзначено
let ageFieldChecked = false; // ні, поле не відзначено
		</pre>
		<p>
			Булеві значення також можуть бути результатом порівнянь:
		</p>

		<pre>
let isGreater = 4 &gt; 1;
alert (isGreater ); // true (результатом порівняння буде " так")
		</pre>
		<h2 id="-null-">Значення null</h2>
		<p>
			Спеціальне значення <code>null</code> не відноситься до жодного з типів, описаних вище.
		</p>

		<p>
			Воно формує окремий тип, який містить тільки значення <code>null</code>:
		</p>

		<pre>
let age = null;
		</pre>
		<p>
			У JavaScript<code>null</code> не є посиланням на неіснуючий об'єкт або нульовим покажчиком, як у деяких інших мовах.
		</p>

		<p>
			Це просто спеціальне значення, яке являє собою нічого, порожньоабо значення невідоме.
		</p>

		<p>
			У наведеному вище коді зазначено, що значення змінної<code>age</code> невідоме.
		</p>
		<h2 id="-undefined-">Значення undefined</h2>
		<p>
			Спеціальне значення <code>undefined</code> також стоїть осібно. Воно формує тип з самого себе так само, як і <code>null</code>.
		</p>

		<p>
			Воно означає, щозначення не було присвоєно.
		</p>

		<p>
			Якщо змінна оголошена, але їй не присвоєно ніякого значення, то її значенням буде <code>undefined</code>:
		</p>

		<pre>
let age;
alert (age); // виведе " undefined"
		</pre>
		<p>
			Технічно ми можемо присвоїти значення<code>undefined</code> будь-якої змінної:
		</p>

		<pre>
let age = 123;
// змінюємо значення на undefined
age = undefined;
alert(age); // "undefined"
		</pre>
		<p>
			...Але так робити не рекомендується. Зазвичай <code>null</code>використовується для присвоєння змінної порожнього або невідомого значення, а<code>undefined</code> - для перевірок, чи була змінна призначена.
		</p>
		<h2 id="h05">Об'єкти та символи</h2>
		<p>
			Тип <code>object</code> (об'єкт) - особливий.
		</p>

		<p>
			Всі інші типи називаються примітивними, тому що їх значеннями можуть бути тільки прості значення (будь то рядок, або число, або щось ще). В об'єктах же зберігають колекції даних або більш складні структури.
		</p>

		<p>
			Об'єкти займають важливе місце в мові і вимагають особливої уваги. Ми розберемося з ними в розділі <info: object> після того, як дізнаємося більше про примітиви.
		</p>

		<p>
			Тип <code>symbol</code>(символ) використовується для створення унікальних ідентифікаторів в об'єктах. Ми згадуємо тут про нього для повноти картини, вивчимо цей тип після об'єктів.
		</p>
		<h2 id="-typeof-type-typeof-">Оператор typeof</h2>
		<p>
			Оператор <code>typeof</code> повертає тип аргументу. Це корисно, коли ми хочемо обробляти значення різних типів по-різному або просто хочемо зробити перевірку.
		</p>

		<p>
			У нього є дві синтаксичні форми:
		</p>
		<ol>
			<li>Синтаксис оператора: <code>typeof x</code>.</li>
			<li>Синтаксис функції: <code>typeof (x)</code>.</li>
		</ol>
		<p>
			Іншими словами, він працює з дужками або без дужок. Результат однаковий.
		</p>

		<p>
			Виклик <code>typeof x</code> повертає рядок з ім'ям типу:
		</p>

		<pre>
			typeof undefined // "undefined"
			typeof 0 // "number"
			typeof 10n // "bigint"
			typeof true // "boolean"
			typeof "foo" // "string"
			typeof Symbol("id") // "symbol"
			typeof Math // "object"  (1)
			typeof null // "object"  (2)
			typeof alert // "function"  (3)
		</pre>
		<p>
			Останні три рядки потребують пояснення:
		</p>
		<ol>
			<li>
				<code>Math</code> - це вбудований об'єкт, який надає математичні операції та константи. Тут він служить лише прикладом об'єкта.
			</li>
			<li>
				Результатом виклику <code>typeof null</code> є <code>object</code>. Це офіційно визнана помилка в <code>typeof</code>, що веде початок з часів створення JavaScript і збережена для сумісності. Звичайно, <code>null</code> не є об'єктом. Це спеціальне значення з окремим типом.
			</li>
			<li>
				Виклик <code>typeof alert</code>повертає <code>function</code>, тому що <code>alert</code> є функцією. Ми вивчимо функції в наступних розділах, де заодно побачимо, що в JavaScript немає спеціального типу функція. Функції відносяться до об'єктного типу. Але <code>typeof</code> обробляє їх особливим чином, повертаючи <code>function</code>. Так теж повелося від створення JavaScript. Формально це невірно, але може бути зручним на практиці.
			</li>
		</ol>
		<h2 id="h06">Підсумок</h2>
		<p>
			У JavaScript є 8 основних типів.
		</p>

		<ul>
			<li><code>number</code> для будь-яких чисел: цілочисельних або чисел з плаваючою точкою; цілочисельні значення обмежені діапазоном <code>±(2<sup>53</sup>-1)</code>.
			</li>
			<li><code>bigint</code> для цілих чисел довільної довжини.</li>
			<li><code>string</code> для рядків. Рядок може містити нуль або більше символів, немає окремого символьного типу.</li>
			<li><code>boolean</code> для<code>true</code> / <code>false</code>.</li>
			<li><code>null</code> для невідомих значень -- окремий тип, що має одне значення <code>null</code>.</li>
			<li><code>undefined</code> для неприсвоєних значень-окремий тип, що має одне значення <code>undefined</code></li>
			<li><code>object</code> для більш складних структур даних</li>
			<li><code>symbol</code> для унікальних ідентифікаторів.</li>
		</ul>
		<p>
			Оператор <code>typeof</code> дозволяє нам побачити, який тип даних збережений у змінній.
		</p>
		<ul>
			<li>Має дві форми: <code>typeof x</code> або <code>typeof(x)</code>.</li>
			<li>Повертає рядок з ім'ям типу. Наприклад, <code>string</code>.</li>
			<li>Для<code>null</code>повертається <code> object </code> -- це помилка в мові, насправді це не об'єкт.</li>
		</ul>
		<p>
			У наступних розділах ми сконцентруємося на примітивних значеннях, а коли познайомимося з ними, перейдемо до об'єктів.
		</p>



		<h1 id="h07">Перетворення типів</h1>
		<p>
			Найчастіше оператори і функції автоматично приводять передані їм значення до потрібного типу.
		</p>

		<p>
			Наприклад, <code>alert</code> автоматично перетворює будь-яке значення до рядка. Математичні оператори перетворюють значення до чисел.
		</p>

		<p>
			Є також випадки, коли нам потрібно явно перетворити значення в очікуваний тип.
		</p>


		<h2 id="h08">Рядкове перетворення</h2>
		<p>
			Рядкове перетворення відбувається, коли потрібно представлення чого-небудь у вигляді рядка.
		</p>

		<p>
			Наприклад <code>alert (value)</code> перетворює значення до рядка.
		</p>

		<p>
			Також ми можемо використовувати функцію<code>String (value)</code>, щоб перетворити значення до рядка:
		</p>

		<pre>
let value = true;
alert(typeof value); // boolean
value = String (value); // тепер value це рядок " true"
alert(typeof value); // string
		</pre>
		<p>
			Перетворення відбувається очевидним чином.<code>false</code> стає <code>false</code>, <code>null</code>стає <code>null</code> і т. п.
		</p>
		<h2 id="h09">Чисельне перетворення</h2>
		<p>
			Чисельне перетворення відбувається в математичних функціях і виразах.
		</p>

		<p>
			Наприклад, коли операція ділення <code>/</code> застосовується не до числа:
		</p>

		<pre>
alert( "6" / "2" ); // 3, рядки перетворюються в числа
		</pre>
			
		<p>
				Ми можемо використовувати функцію<code>Number (value)</code>, щоб явно перетворити <code>value</code> до числа:
			</p>

			<pre>
let str = "123";
alert(typeof str); // string
let num = Number (str); // стає числом 123
alert(typeof num); // number
			</pre>
			<p>
				Явне перетворення часто застосовується, коли ми очікуємо отримати число з строкового контексту, наприклад з текстових полів форм.
			</p>

			<p>
				Якщо рядок не може бути явно приведена до числа, то результатом перетворення буде <code>NaN</code>. Наприклад:
			</p>

			<pre>
let age = Number ("будь-який рядок замість числа");
alert (age); // NaN, перетворення не вдалося
			</pre>
			<p>
				Правила чисельного перетворення:
			</p>

			<p>
				/ Значення / перетворюється в... |
				|----------|-------------|
				|<code>undefined</code>|<code>NaN</code>|
				|<code>null</code>|<code>0</code>|
				|<code>true&nbsp;/&nbsp;false</code> | <code>1</code> / <code>0</code> |
				| <code>string</code> / пробільні Символи по краях обрізаються. Далі, якщо залишається порожній рядок, то отримуємо <code>0</code>, інакше з непорожнього рядка зчитується число. При помилці результат <code>nan</code>.|
			</p>

			<p>
				Приклад:
			</p>

			<pre>
				alert( Number("   123   ") ); // 123
					alert (Number ("123z")); // NaN (помилка читання числа на місці символу " z")
						alert( Number(true) );        // 1
							alert( Number(false) );       // 0
							</pre>
							<p>
								Врахуйте, що <code>null</code> і <code>undefined</code> поводяться по-різному. Так, <code>null</code> стає нулем, тоді як <code>undefined</code> приводиться до <code>NaN</code>.
							</p>

							<p>
								Більшість математичних операторів також виробляє дане перетворення, як ми побачимо в наступному розділі.
							</p>
							<h2 id="h010">Логічне перетворення</h2>
							<p>
								Логічне перетворення найпростіше.
							</p>

							<p>
								Відбувається в логічних операціях(пізніше ми познайомимося з умовними перевірками і подібними конструкціями), але також може бути виконано явно за допомогою функції <code>Boolean (value)</code>.
							</p>

							<p>
								Правило перетворення:
							</p>
							<ul>
								<li>Значення, які інтуїтивно порожні, на зразок <code>0</code>, порожнього рядка, <code>null</code>, <code>undefined</code> і <code>NaN</code>, стають <code>false</code>.</li>
								<li>Всі інші значення стають<code>true</code>.</li>
							</ul>
							<p>
								Наприклад:
							</p>

							<pre>
								alert( Boolean(1) ); // true
									alert( Boolean(0) ); // false
										alert (Boolean ("Привіт!") ); // true
											alert( Boolean("") ); // false
											</pre>
											<p>
												warn header= зауважимо, що рядок з нулем<code>\0\</code> - це<code>true</code>
												Деякі мови (наприклад, PHP) сприймають рядок <code>0</code> як <code>false</code>. Але в JavaScript, якщо рядок не порожній, то він завжди <code>true</code>.
											</p>

											<pre>
												alert( Boolean("0") ); // true
												alert (Boolean ( "" )); // пробіл це теж true (будь-яка непорожня рядок це true)
											</pre>
											<h2 id="h011">Разом</h2>
											<p>
												Існує 3 найбільш широко використовуваних перетворення: рядкове, чисельне і логічне.
											</p>

											<p>
												<code>cтрокове</code> -- відбувається, коли нам потрібно щось вивести. Може бути викликано за допомогою <code>String (value)</code>. Для примітивних значень працює очевидним чином.
											</p>

											<p>
												<code>чисельне</code> -- відбувається в математичних операціях. Може бути викликано за допомогою <code>Number (value)</code>.
											</p>

											<p>
												Перетворення підпорядковується правилам:
											</p>

											<p>
												/ Значення / Стає... |
												|-------|-------------|
												|<code>undefined</code>|<code>NaN</code>|
												|<code>null</code>|<code>0</code>|
												|<code>true&nbsp;/&nbsp;false</code> | <code>1 / 0</code> |
												| <code>string</code> / пробільні Символи по краях обрізаються. Далі, якщо залишається порожній рядок, то отримуємо <code>0</code>, інакше з непорожнього рядка зчитується число. При помилці результат <code>nan</code>.|
											</p>

											<p>
												<code>Логічне</code> -- відбувається в логічних операціях. Може бути викликано за допомогою <code>Boolean (value)</code>.
											</p>

											<p>
												Підпорядковується правилам:
											</p>

											<p>
												/ Значення / Стає... |
												|----------|-------------|
												|<code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code></code> |<code>false</code>|
												/ будь-яке інше значення  <code>true</code> |
											</p>

											<p>
												Більшу частину з цих правил легко зрозуміти і запам'ятати. Особливі випадки, в яких часто допускаються помилки:
											</p>

											<p>
												<code>undefined</code>.при чисельному перетворенні стає <code>NaN</code>, не <code>0</code>.
											</p>
											<ul>
												<li><code>0</code> і рядки з одних пробілів типу <code></code> при логічному перетворенні завжди <code>true</code>.</li>
											</ul>
										


											<h2 id="h012">Контрольні запитання</h2>
											<ol>

												<li> </li>

											</ol>
										</div>
									</body>
									</html>